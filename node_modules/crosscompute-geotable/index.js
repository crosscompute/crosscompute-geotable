function get_geotable_adjective(key) {
  var adjective_string = 'streets|light|dark|satellite|streets-satellite|wheatpaste|streets-basic|comic|outdoors|run-bike-hike|pencil|pirates|emerald|high-contrast'.replace(/-/g, '[-_]');
  try {
    return RegExp('(' + adjective_string + ')_geotable').exec(key)[1].replace(/_/g, '-');
  } catch(e) {
    return 'streets';
  }
}

function draw_map(k, v) {

  // Get v as geojson
  // Add geojson layer
  // Add styling
  // Add interaction

  var map_id = k + '-map',
    table_id = k + '-table';
  var map = L.mapbox.map(map_id, 'mapbox.' + get_geotable_adjective(k)),
    features = [],
    feature_packs = v[0],
    properties = v[1];
  for (var i = 0; i < feature_packs.length; i++) {

    var feature,
      p = feature_packs[i],
      geometry_type_id = p[0],
      geometry_coordinates = p[1],
      is_line = geometry_type_id == 2 || geometry_type_id == 3,
      d = $.extend({
        'color': 'black',
        'weight': is_line ? 5 : 2,
        'opacity': 0.7,
        'fillColor': is_line ? '#c9302c' : '#286090',
        'fillOpacity': 0.5
      }, properties, p[2]);

    switch(geometry_type_id) {
      case 1:
        feature = L.circleMarker(geometry_coordinates, d);
        d.radius_in_pixels && feature.setRadius(+d.radius_in_pixels);
        add_feature(features, feature, i, table_id);
        break;
      case 2:
        d['color'] = d['fillColor'];
        feature = L.polyline(geometry_coordinates, d);
        add_feature(features, feature, i, table_id);
        break;
      case 3:
        d['color'] = d['fillColor'];
        for (var j = 0; j < geometry_coordinates.length; j++) {
          feature = L.polyline(geometry_coordinates[j], d);
          add_feature(features, feature, i, table_id);
        }
        break;
      case 4:
        feature = L.polygon(geometry_coordinates, d);
        add_feature(features, feature, i, table_id);
        break;
      case 5:
        for (var j = 0; j < geometry_coordinates.length; j++) {
          feature = L.polygon(geometry_coordinates[j], d);
          add_feature(features, feature, i, table_id);
        }
        break;
    }

  }
  if (features.length) {
    map.fitBounds(L.featureGroup(features).addTo(map).getBounds(), {
      animate: false
    }).on('click', function() {
      $('#' + table_id).hide();
    });
  }
}

function add_feature(features, feature, index, table_id) {
  // !!! quickfix until we move to mapbox gl

  feature.geotable = {
    'table_id': table_id,
    'tbody_id': table_id.replace('-table', '-row') + index
  };

  feature.on('click', function(o) {
    var a = this.geotable;
    var b = $('#' + a.tbody_id).show();
    $('#' + a.table_id + ' tbody').not(b).hide();
    $('#' + a.table_id).show();
    L.DomEvent.stopPropagation(o);
  });

  features.push(feature);
}

$('.geotable-upload').on('uploaded.ir', function(e, d) {
  import_upload(e, d, CC.geotable.import_url, function($feedback, $argument) {
    var script_text = $argument.find('script').text();
    var script_json = $.trim(
      script_text.replace(/'/g, '"').replace(/.* = /, '')).slice(0, -1);
    draw_map($argument.attr('id'), $.parseJSON(script_json));
  });
});
